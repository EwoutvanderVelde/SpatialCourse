---
title: "final Project: Geographically Weighted Regression"
output: html_document
date: "2023-04-01"
author:
---

```{r}
#install and load libraries
#In this practical we need an additional package to run the GWR models, this package is called "GWmodel"
easypackages::packages ("sf", "sp", "spdep", "spatialreg", "GWmodel", "tmap", "mapview", "car", "RColorBrewer", "cowplot", "leafsync", "leaflet.extras2", "mapview", "tidyverse")

```


```{r}
# Loading the spatial data. This s GEOPACKAGE format data which is a really efficient GIS data format, compared to shape files
# Use the SF package to bring the data
housesdata <- st_read("data/EN-Merged-properties-cdmx.gpkg")
```

```{r}
# The data projected in  Mexico ITRF92/LCC (EPSG:6362)
# The spatial unit of measurement is: meters (m)

# Check the variable names
names(housesdata)

#Check houses data structure
str(housesdata)
```


```{r}
#Making subset of data to work with less points for now
small_set = sample_n(housesdata, 200)

#make this example reproducible 
set.seed(1) 

#use 70% of dataset as training set and 30% as test set
sample <- sample(c(TRUE, FALSE), nrow(small_set), replace=TRUE, prob=c(0.7,0.3))
train <- small_set[sample, ]
test   <- small_set[!sample, ]
train
```


First define the model equation:

```{r}
# Set the question
eq_houses <- price_small ~ lot_size + bedrooms + bathrooms + high_impact.area + low_impact.area + parks + school + univ + hospital + sport_facility + supermarket + mall + historic + museum + industry + subway + bus
```

# Fitting GWR and exploring nonstationarity

## Adaptive Kernel GWR: Selecting bandwidth, fitting GWR
The spatial kernel for GWR can be used in two ways: Fixed or Adaptive. The fixed kernel has a fixed bandwidth distance to select the data points fall within the region.

Adaptive Kernel use varying bandwidth to define a region around regression points. Here the selection of fixed vs adaptive kernel depend on the data distribution within the study region. If we use a Fixed Kernel, what is the bandwidth distance we should consider? In addition, what is the shape of the Kernel should we select?

Adaptive kernel do not depend on fixed distance as bandwidth. In this approach the kernel adapt in size to variations in the density of the spatial data so that the kernels have larger bandwidths where the data are sparse and have smaller bandwidths where the data are plentiful. Here, the bandwidth is not distance but numbers of nearest neighbors best fitted based on the data density. Here the k-nearest neighbors expressed as the proportion of observations (in this case the proportion of neighborhoods within at the neighborhoods in the data set). We can use the following code to find the optimal proportion as bandwidth.

```{r}
#Before we do any analysis for GWR we need to convert our imported sf object into a sp spatial object. As the GWmodel package usually works on sp objects
#converting the sf polygon into sp object
housesdata_sp <- as_Spatial(housesdata)
housesdata_sp
```


```{r}
#fit the adaptive kernel 
#find adaptive kernel using gaussian function
abw <- bw.gwr(eq_houses,
             approach = "AIC", #specified by CV for cross-validation approach or by AIC corrected (AICc), we used AIC 
             adaptive = TRUE,
             kernel="gaussian", #this can be different function e.g., bisquare,exponential, depend on the prior understanding or choice of the modeler
             data=housesdata_sp) #give the sp data created earlier
```

```{r}
abw
```

Here the model optimization coverage at number of nearest neighbors: 199, indicating in our data set for the given equation, the lowest AIC could be achieved with data from nearest 18 observations and the model use data from the nearest 18 neighbors to compute each local weighted regression.Which is about 1.07% of the Greater Manchester data (we have 1673 neighbors). Let us fit the GWR model with this kernel type used, such as if you use bisquare you will get different number of nearest neighbors. Let us use this adaptive kernel to fit an adaptive GWR model. The following code fit the model.

```{r}
#fitting the model with gwr.basic function
a.gwr <- gwr.basic(eq_houses, #the equation
             adaptive = TRUE,
             kernel="gaussian",
             bw = abw,
             data=housesdata_sp) 

#print the model result
a.gwr
```

The printed results have different sections, the first part summarized the model specification. Then gave the “Results of Global Regression”, which is simple OLS model. In the linear model we get only one estimate, for the Green_avail = -30.180, p <0.05. Then we look in the “Results of Geographically Weighted Regression”, we see for each input of the model we get several coefficient estimates, such as for Green_avail local coefficient estimate varies from -147.254 to -2.4499 between the 1st and 3rd quartiles (this numbers will be different if you use different kernel and variables in the model); these shows the local estimates of the effect of greenspace on premature mortality is different for different neighbors, and the median value of the coefficient is -11.151, which is way lower than the OLS model estimate and also different from the error model estimate. In summary, the GWR indicated nonstationarity effect of greenspace exposure on health outcome.

The interesting comparison here is also the overall model AIC and pseudo R-square values, the GWR model has lower AICs than the OLS, and error model, and also have greater R-square! Meaning this is a better model explaining the relations we previously model. Think why?

## Exploring and mapping the results
The GWR model object holds many information we can explore the model object and map the results for better understanding on what the model actually produced. First, let us look at the names of objects/arrays the model object stored. Here, GW.arguments, is the model summary, lm is OLS model, SDF is the most important one, which stored the spatial data frame, in which we can look for the local coefficients, t-test value and map it. Let us get the SDF out as an spatial data frame using the following code.

```{r}
names(a.gwr)
```

```{r}
agwr_sf = st_as_sf(a.gwr$SDF)
```

Now, let us map some information! Let us use tmap package for some interesting maps. We can plot the local coefficient and R2 values. And we can also compare them using the slider mapping function in mapview package

```{r}
#produce the maps
agwrM1 <- qtm(agwr_sf, "high_impact.area") #local coefficent values for greenspace relation with mortality
agwrM2 <- qtm(agwr_sf, "lot_size")
agwrM3 <- qtm(agwr_sf, "subway")
agwrRrsq <- qtm (agwr_sf, "Local_R2") #local R2

tmap_arrange(agwrM1, agwrM2, agwrM3, agwrRrsq, asp = 1, ncol = 2)
```

```{r}
# Can try looking at each individually also using mapview
agwr_mv1 <- mapview::mapview(agwr_sf, zcol = "high_impact.area", col.regions= brewer.pal(11, "RdYlGn"), map.type = "CartoDB.Positron") 
```

```{r}
#eq_houses <- price ~ lot_size + bedrooms + bathrooms + high_impact.area + low_impact.area + parks + #school + univ + hospital + sport_facility + supermarket + mall + historic + museum + industry + #subway + bus
agwr_mv2 <- mapview::mapview(agwr_sf, zcol = "high_impact.area", col.regions= brewer.pal(11, "RdYlGn"), map.type = "CartoDB.Positron") 
```

```{r}
agwr_mv1 | agwr_mv2
```

Here, the negative coefficients indicate, higher/positive values of that variable associated with lower pre mature mortality; and vice versa for positive coefficients. However, such effect is not consistent and effect size also varies depending on where we are looking in the map, this clearly indicate the relations varies over space and global model even which consider spatial dependency cannot find such pattern. Moreover, you can also see the R2 value varies over space, indicate the variables do not always explain mortality similarly for all neighborhoods.

Check the statistical significance locally! Here we can plot if the coefficients are statistically significant or not for all the neighborhoods, or they are only significant for certain neighborhoods. Here we need to go into the t-values from which p-values are derived. Significant coefficient estimates are those whose t-values are less than -1.96 or greater than +1.96. It possible to identify and map these locations from the GWR outputs which have the t-values (_TV) for each input variable.

```{r}
# Determine which are significant for the greenspace variable
Greentvalaw = agwr_sf %>% dplyr::select(all_of("Green_avail_TV")) %>% st_drop_geometry()

agwrGreensig = Greentvalaw < -1.96 | Greentvalaw > 1.96 # This will create a new layer polygons with these value ranges

# Go for tmap viewer mode for dynamically explore the map
tmap_mode("view")
```

```{r}
tm_shape(agwr_sf) +
  tm_fill("Green_avail",midpoint = 0) + tm_style("col_blind")+
  tm_basemap ("OpenStreetMap") +
  tm_layout(legend.position = c("right","top"))+
  # now add the tvalues layer
  tm_shape(agwr_sf[agwrGreensig,]) + tm_borders()
```

This map shows only for a new neighborhoods the t-value, thus the p-values indicate a significant relation at p < 0.05! Which means, the global relations indicating green space is significantly associated with mortality is only true for cretin places, not for all! Which is interesting! Now play with plotting the same map for PM10 variable.

```{r}
# Determine which are significant for the greenspace variable
PM10tvalaw = agwr_sf %>% dplyr::select(all_of("PM10_TV")) %>% st_drop_geometry()

agwrPM10sig = PM10tvalaw < -1.96 | PM10tvalaw > 1.96 # This will create a new layer polygons with these value ranges

# Go for tmap viewer mode for dynamically explore the map
tmap_mode("view")
```

```{r}
tm_shape(agwr_sf) +
  tm_fill("PM10", midpoint = 0) + tm_style("col_blind")+
  tm_basemap ("OpenStreetMap") +
  tm_layout(legend.position = c("right","top"))+
  # Now add the tvalues layer
  tm_shape(agwr_sf[agwrPM10sig,]) + tm_borders()
```
